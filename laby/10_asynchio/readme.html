<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
<meta name="Author" content="Krzysztof Lichota &lt;lichota@mimuw.edu.pl&gt;">
<title>Asynchroniczne wej¶cie/wyj¶cie (aio)</title></head>
<body>
<h1>Wstêp</h1>
Asynchroniczne wej¶cie/wyj¶cie (ang. <i>asynchronous I/O</i>) to technika zarz±dzania
¿±daniami wej¶cia/wyj¶cia w oderwaniu od w±tk&oacute;w wykonywania.

<p>
Standardowe operacje wej¶cia/wyj¶cia, np. <i>read()</i> i <i>write()</i> powoduj±
zablokowanie w±tku wykonuj±cego dan± operacjê do czasu jej zakoñczenia.
Powoduje to, ¿e w±tek mo¿e naraz zainicjowaæ tylko jedno ¿±danie
wej¶cia/wyj¶cia. W przypadku dostêpu do zwyk³ych plik&oacute;w mo¿liwe jest
zniwelowanie tej wady poprzez zapamiêtywanie przez system danych w pamiêci
podrêcznej (zapisywanie z op&oacute;¼nieniem dla operacji zapisu i czytanie z
wyprzedzeniem dla operacji odczytu). 

</p><p>
S± jednak zastosowania, w kt&oacute;rych proces
chce mieæ wiêksz± kontrolê nad wykorzystaniem pamiêci podrêcznej (np.
bazy danych) lub dostêp do urz±dzenia nie jest buforowany (tzw. urz±dzenia
surowe - ang. <i>raw devices</i>).

</p><p>
U¿ycie asynchronicznego wej¶cia/wyj¶cia umo¿liwia zarz±dzanie przez jeden
w±tek wieloma ¿±daniami wej¶cia wyj¶cia naraz i precyzyjn± kontrolê nad
rozpoczêciem i zakoñczeniem ¿±dania wej¶cia/wyj¶cia.

</p><p>
Istnieje kilka standard&oacute;w operacji asynchronicznego wej¶cia/wyj¶cia. W
¶wiecie Uniksa obowi±zuje standard <b>POSIX.1b</b> i w³a¶nie ten standard bêdzie
dalej opisany.

</p><h1>Standard asynchronicznego wej¶cia/wyj¶cia POSIX.1b</h1>
<h2>¯±dania wej¶cia/wyj¶cia</h2>
W standardowych operacjach wej¶cia/wyj¶cia wszystkie informacje opisuj±ce
¿±danie wej¶cia/wyj¶cia zawarte s± w parametrach wywo³ywanej funkcji
systemowej. Poniewa¿ operacje asynchronicznego wej¶cia/wyj¶cia wykonuj± siê w
oderwaniu od w±tku wykonywania, <u>wszystkie</u> parametry opisuj±ce ¿±danie s±
zebrane w jednej strukturze <i>aiocb</i>. Wszystkie funkcje asynchronicznego
wej¶cia/wyj¶cia operuj± w³a¶nie na takich strukturach.

<p>
Najwa¿niejsze pola struktury aiocb:
</p><ul>
	<li><b>int aio_fildes</b> - deskryptor pliku, kt&oacute;rego dotyczy
	¿±danie. 
	</li><li><b>off_t aio_offset</b> - pozycja w pliku, od kt&oacute;rej ma siê
	rozpocz±æ operacja. 
	</li><li><b>size_t aio_nbytes</b> - liczba bajt&oacute;w do
	odczytania/zapisania.
	</li><li><b>void *aio_buf</b> - wska¼nik do bufora zawieraj±cego dane do
	zapisania lub gdzie zostan± umieszczone odczytane dane.
	</li><li><b>int aio_lio_opcode</b> - operacja, kt&oacute;ra ma zostaæ wykonana
	(pole u¿ywane tylko w przypadku rozpoczêcia kilku operacji naraz
	za pomoc± funkcji <a href="#lio_listio"><i>lio_listio()</i></a>).
	</li><li><b>struct sigevent aio_sigevent</b> - struktura okre¶laj±ca
	spos&oacute;b powiadomienia o zakoñczeniu ¿±dania (patrz 
	<a href="#powiadamianie">Powiadamianie o zakoñczeniu operacji</a>).
</li></ul>

<h2>Rozpoczêcie operacji transmisji</h2>
Do rozpoczêcia operacji transmisji mo¿na u¿yæ jednej z trzech funkcji:
<ul>
	<li><b>aio_read()</b> - rozpoczêcie jednej operacji odczytu.
	</li><li><b>aio_write()</b> - rozpoczêcie jednej operacji zapisu.
	</li><li><b>lio_listio()</b> - rozpoczêcie kilku operacji odczytu/zapisu
	naraz.
</li></ul>

<h3>int aio_read(struct aiocb *aiocbp)</h3>
Rozpoczyna operacjê odczytu opisywan± struktur± <i>aiocbp</i>. Pola
<i>aio_offset</i> i <i>aio_nbytes</i> okre¶laj± po³o¿enie i d³ugo¶æ odczytywanego obszaru.
Wczytane dane zostan± zapisane w buforze wskazywanym przez <i>aio_buf</i>.

<p>
Funkcja zwraca 0, je¶li ¿±danie zosta³o zarejestrowane. W przeciwnym wypadku
funkcja zwraca -1 i ustawia odpowiednio zmienn± errno.

</p><h3>int aio_write(struct aiocb *aiocbp)</h3>
Rozpoczyna operacjê zapisu opisywan± struktur± <i>aiocbp</i>. Pola
<i>aio_offset</i> i <i>aio_nbytes</i> okre¶laj± po³o¿enie i d³ugo¶æ
zapisywanego obszaru.
Dane do zapisania znajduj± siê w buforze okre¶lonym przez <i>aio_buf</i>.

<p>
Funkcja zwraca 0, je¶li ¿±danie zosta³o zarejestrowane. W przeciwnym wypadku
funkcja zwraca -1 i ustawia odpowiednio zmienn± errno.

</p><h3><a name="lio_listio">int lio_listio(int mode, struct aiocb *const list[], int nent, struct
sigevent *sig)</a></h3>
Rozpoczyna operacje opisywane przez tablicê <i>list</i> wska¼nik&oacute;w do struktur
aiocb. Liczbê wska¼nik&oacute;w okre¶la parametr <i>nent</i>. Rodzaj operacji do
wykonania wskazuje pole <i>aio_lio_opcode</i> w ka¿dej ze struktur aiocb
wskazywanych przez elementy tablicy. Mo¿liwe warto¶ci tego pola to:
<ul>
	<li><b>LIO_READ</b> - zostanie wykonana operacja odczytu.
	</li><li><b>LIO_WRITE</b> - zostanie wykonana operacja zapisu.
	</li><li><b>LIO_NOP</b> - struktura zostanie zignorowana (brak operacji).
</li></ul>

<p>Parametr <i>mode</i> okre¶la czy operacja ma siê wykonaæ w spos&oacute;b
blokuj±cy, czy asynchronicznie. Mo¿e przybraæ jedn± z dw&oacute;ch warto¶ci:
</p><ul>
	<li><b>LIO_WAIT</b> - powr&oacute;t z funkcji nast±pi po zakoñczeniu
	wszystkich wskazanych operacji (tryb blokuj±cy).
	</li><li><b>LIO_NOWAIT</b> - powr&oacute;t z funkcji nast±pi po zarejestrowaniu wszystkich
	operacji (tryb asynchroniczny).
</li></ul>

<p>
Parametr <i>sig</i> okre¶la spos&oacute;b powiadamiania, kt&oacute;ry ma zostaæ u¿yty do
powiadomienia o zakoñczeniu ¿±dañ (patrz 
<a href="#powiadamianie">Powiadamianie o zakoñczeniu operacji</a>).

</p><p>
Funkcja zwraca 0, je¶li wszystkie ¿±dania zosta³y zarejestrowane (lub
pomy¶lnie zakoñczone, je¶li tryb wywo³ania by³ blokuj±cy). W przeciwnym wypadku
funkcja zwraca -1 i ustawia odpowiednio zmienn± errno.

</p><h2><a name="powiadamianie">Powiadamianie o zakoñczeniu operacji</a></h2>
Spos&oacute;b powiadomienia o zakoñczeniu operacji wej¶cia wyj¶cia okre¶la
struktura <i>sigevent</i>. Jest ona czê¶ci± struktury aiocb opisuj±cej
¿±danie lub zostaje przekazana w wywo³aniu funkcji <i>lio_listio()</i>.

<p>
Spos&oacute;b powiadamiania okre¶la pole <i>sigev_notify</i>. S± nastêpuj±ce
sposoby powiadamiania:
</p><ul>
	<li><b>SIGEV_NONE</b> - brak powiadamiania, stan operacji musi byæ
	rêcznie sprawdzany, np. za pomoc± funkcji <i>aio_error()</i> lub w±tek musi
	zaczekaæ na zakoñczenie operacji za pomoc± funkcji
	<i>aio_suspend()</i>.
	</li><li><b>SIGEV_SIGNAL</b> - po zakoñczeniu operacji zostanie wys³any
	sygna³, numer sygna³u okre¶la pole <i>sigev_signo</i>.
	</li><li><b>SIGEV_THREAD</b> - po zakoñczeniu operacji wywo³ana zostanie
	(w oddzielnym w±tku) funkcja, kt&oacute;rej adres znajduje siê w polu
	<i>sigev_notify_function</i>.
</li></ul>

<h2>Sprawdzanie stanu operacji</h2>
Stan operacji mo¿na sprawdziæ wywo³uj±c odpowiedni± funkcjê na jej
strukturze aiocb.

<h3>int aio_error(const struct aiocb *aiocbp)</h3>
Sprawdza stan operacji. Mo¿e zwr&oacute;ciæ:
<ul>
	<li><b>EINPROGRESS</b> - operacja jeszcze siê nie zakoñczy³a.
	</li><li><b>0</b> - operacja zakoñczy³a siê pomy¶lnie. 
	</li><li><b>inna warto¶æ</b>	- operacja zakoñczy³a siê b³êdem, zwr&oacute;cona
	warto¶æ jest analogiczna do warto¶ci errno zwr&oacute;conej w wywo³aniu
	funkcji <i>read()</i> lub <i>write()</i>.
</li></ul>

<h3>ssize_t aio_return(const struct aiocb *aiocbp)</h3>
Pozwala sprawdziæ liczbê odczytanych/zapisanych bajt&oacute;w. Liczba ta ma
analogiczne znaczenie jak liczba zwracana przez funkcje <i>read()</i> lub
<i>write()</i>.

<p>
Tej funkcji mo¿na u¿yæ dopiero kiedy operacja siê zakoñczy. <b>Uwaga!</b> Mo¿na j± wywo³aæ
tylko raz dla ka¿dego zakoñczonego ¿±dania transmisji.

</p><h2>Oczekiwanie na zakoñczenie operacji</h2>
<h3>int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout)</h3>
Funkcja ta zawiesza w±tek, kt&oacute;ry j± wykona do czasu a¿ kt&oacute;re¶ z ¿±dañ
wskazywanych przez wska¼nik w tablicy <i>list</i> nie zostanie zakoñczone.

<p>
Pole <i>nent</i> okre¶la liczbê wska¼nik&oacute;w w tablicy. Pole <i>timeout</i>
okre¶la czas po jakim ma nast±piæ powr&oacute;t z funkcji, nawet je¶li ¿adne z
¿±dañ nie zostanie zakoñczone. Je¶li w polu <i>timeout</i> znajduje siê NULL,
oczekiwanie nie bêdzie przerwane do czasu zakoñczenia ¿±dania (o ile nie
zostanie dostarczony sygna³ przerywaj±cy funkcjê systemow±).

</p><p>Podanie wska¼nika NULL w polu tablicy <i>list</i> powoduje zignorowanie
tego pola tablicy.

</p><p>
Funkcja zwraca 0, je¶li kt&oacute;re¶ z ¿±dañ zosta³o zakoñczone. W przeciwnym
wypadku funkcja zwraca -1 i ustawia odpowiednio zmienn± errno.

</p><h2>Dalsze informacje</h2>
Przedstawione funkcje s³u¿± do operowania asynchronicznym wej¶ciem/wyj¶ciem
w podstawowym zakresie. Do innych u¿ytecznych funkcji nale¿±:
<ul>
	<li><b>aio_fsync()</b> - pozwala zaczekaæ na zakoñczenie wszystkich
	operacji zwi±zanych z okre¶lonym deskryptorem pliku.
	</li><li><b>aio_cancel()</b> - pozwala anulowaæ ¿±danie.
	</li><li><b>aio_init()</b> - pozwala okre¶liæ parametry implementacji
	AIO. 
</li></ul>

<p>
W strukturze aiocb znajduje siê r&oacute;wnie¿ nieom&oacute;wione pole <i>aio_reqprio</i>,
kt&oacute;re s³u¿y do nadawania priorytetu ¿±daniom wej¶cia/wyj¶cia.

</p><p>
Dalsze szczeg&oacute;³owe informacje o standardzie AIO, dok³adny opis parametr&oacute;w i
warto¶ci zwracanych przez poszczeg&oacute;lne funkcje mo¿na znale¼æ w 
<!--A HREF="http://www.gnu.org/manual/glibc-2.2.5/html_node/Asynchronous-I-O.html"-->
<a href="http://www.gnu.org/software/libc/manual/html_node/Asynchronous-Reads_002fWrites.html#Asynchronous-Reads_002fWrites">
opisie standardu asynchronicznego wej¶cia/wyj¶cia POSIX.1b w bibliotece GLIBC</a>.

</p><h2>Implementacja AIO w Linuksie</h2>
W celu pe³nego korzystania z zalet AIO, j±dro systemu musi wspieraæ
asynchroniczne ¿±dania wej¶cia/wyj¶cia. Je¶li takiego wsparcia nie ma,
biblioteka GLIBC emuluje asynchroniczne wej¶cie/wyj¶cie za pomoc± puli
w±tk&oacute;w wykonuj±cych operacje wej¶cia/wyj¶cia. Parametry tej emulacji mo¿na
ustawiæ za pomoc± funkcji <i>aio_init()</i>.

<p>
Standardowe j±dro Linuksa w wersji 2.6.x zawiera obs³ugê asynchronicznego
wej¶cia/wyj¶cia.</p><p>Dla wersji 2.4.x&nbsp; istniej± ³aty dodaj±ce takie wsparcie.&nbsp;</p><p><span style="font-style: italic;">Uwaga</span>:
niekt&oacute;re operacje (np. dopisywanie na koñcu pliku) i
niekt&oacute;re systemy plik&oacute;w, zw³aszcza we wcze¶niejszych
wersjach serii 2.6 mog± powodowaæ problemy, np. blokowaæ wykonanie
programu. W razie w±tpliwo¶ci, najlepiej zbadaæ zachowanie programu w
interesuj±cym nas zastosowaniu.

</p><h2>Szczeg&oacute;³y techniczne</h2>
W celu korzystania z AIO nale¿y do³±czyæ plik nag³&oacute;wkowy <b>aio.h</b> i
³±czyæ program wykonywalny z bibliotek± <b>librt</b>.

<h1>Inne implementacje asynchronicznego wej¶cia/wyj¶cia</h1>
AIO nie jest jedynym ani najlepszym standardem asynchronicznego wej¶cia/wyj¶cia.
Asynchroniczne wej¶cie/wyj¶cie jest np. czê¶ci± interfejsu Win32 u¿ywanego w
systemach Windows NT/2000/XP.

<h1>Program przyk³adowy</h1>
Za³±czony program przyk³adowy <a href="aio-copy.c"><b>aio-copy</b></a> u¿ywa interfejsu AIO do
wykonywania jednocze¶nie kilku kopii jednego pliku. Wszystkie operacje
wej¶cia/wyj¶cia obs³ugiwane s± przez jeden w±tek g³&oacute;wny.

<h2>Zasada dzia³ania</h2>
Sta³a <b>NUM_ASYNC_IO</b> okre¶la ile mo¿e jednocze¶nie siê wykonywaæ operacji
odczytu. Z ka¿dym ¿±daniem odczytu zwi±zane jest <b>num_copies</b> (liczba
kopii) ¿±dañ zapisu - po jednym dla ka¿dej kopii. Ka¿de ¿±danie odczytu i
jego ¿±dania zapisu stanowi± jedn± <i>przegr&oacute;dkê</i> (ang. <i>slot</i>),
niezale¿n± od innych.

<p>Na pocz±tku dzia³ania programu inicjowany jest odczyt NUM_ASYNC_IO
pierwszych fragment&oacute;w pliku. Nastêpnie w±tek g³&oacute;wny za pomoc± funkcji
<i>aio_suspend()</i> czeka na zakoñczenie kt&oacute;rej¶ operacji wej¶cia/wyj¶cia.

</p><p>
Po zakoñczeniu operacji odczytu rozpoczynane s± wszystkie operacje zapisu odczytanych danych
do plik&oacute;w kopii. 

</p><p>
Kiedy zakoñczy siê operacja zapisu, sprawdzane jest, czy wszystkie operacje
zapisu dla danej przegr&oacute;dki siê zakoñczy³y. Je¶li tak, przegr&oacute;dka jest znowu
wolna, wiêc inicjowany jest odczyt kolejnego fragmentu pliku do tej
przegr&oacute;dki i cykl rozpoczyna siê od nowa.

</p><h2>Przedstawianie stanu ¿±dañ</h2>
Zdefiniowanie makra <i>SHOW_IO_STATUS</i> powoduje przedstawianie stanu ¿±dañ w momencie, 
gdy nast±pi zakoñczenie kt&oacute;rego¶ ¿±dania. Stan ka¿dego aktywnego ¿±dania
jest okre¶lony liter±:
<ul>
	<li><b>W</b> - zakoñczone ¿±danie zapisu.
	</li><li><b>w</b> - ¿±danie zapisu w trakcie realizacji.
	</li><li><b>R</b> - zakoñczone ¿±danie odczytu
	</li><li><b>r</b> - ¿±danie odczytu w trakcie realizacji.
</li></ul>

<h2>Zadania</h2>

Oto propozycje zadañ do samodzielnego wykonania, uporz±dkowane wed³ug
rosn±cej trudno¶ci:
<ol>
	<li>Po zakoñczeniu operacji wej¶cia/wyj¶cia jest sprawdzane, czy
	operacja zakoñczy³a siê pomy¶lnie, ale nie jest sprawdzone, czy
	liczba przeczytanych/zapisanych bajt&oacute;w jest zgodna z tym, co zosta³o zawarte w
	¿±daniu (liczbê przeczytanych/zapisanych bajt&oacute;w zwraca funkcja
	<i>aio_return()</i>). Nale¿y dodaæ obs³ugê tego przypadku.
	
	</li><li>Rozpoczêcie operacji zapisu do wszystkich kopii w przegr&oacute;dce (i
	pocz±tkowe odczytanie fragment&oacute;w pliku do przegr&oacute;dek) jest
	zrealizowane za pomoc± kilku wywo³añ
	<i>aio_write()</i> (<i>aio_read()</i>). Nale¿y to zrealizowaæ za
	pomoc± jednego wywo³ania funkcji <i>lio_listio()</i>.
	
	</li><li>Po zakoñczeniu wszystkich operacji zapisu nie mo¿na rozpocz±æ
	natychmiast kolejnych operacji zapisu w tej przegr&oacute;dce, poniewa¿
	dane musz± zostaæ najpierw wczytane do bufora. Efektywniejszym
	rozwi±zaniem jest <b>wczytanie z wyprzedzeniem</b> danych do innego
	bufora tak, by w momencie zakoñczenia zapis&oacute;w mo¿na by³o siê
	prze³±czyæ na inny bufor i rozpocz±æ od razu operacje zapisu.
	Nale¿y zaimplementowaæ pulê bufor&oacute;w do czytania z wyprzedzeniem. 
	Pula tych bufor&oacute;w ma byæ wsp&oacute;lna dla wszystkich przegr&oacute;dek, to
	znaczy ¿e ka¿da przegr&oacute;dka mo¿e wzi±æ gotowy bufor z puli. Je¶li
	nie ma wczytanego bufora w puli, nale¿y wczytywaæ dane do bufora
	tak, jak to jest zrealizowane obecnie. <u>Uwaga:</u> nie wolno
	kopiowaæ danych miêdzy pul± bufor&oacute;w do wczytywania z wyprzedzeniem a
	buforami u¿ywanymi w przegr&oacute;dkach - ma nastêpowaæ wymiana aktualnie
	u¿ywanego przez przegr&oacute;dkê bufora na bufor z wczytanymi danymi.
	Mo¿na za³o¿yæ, ¿e rozmiar puli bufor&oacute;w do czytania z wyprzedzeniem
	jest dany sta³± NUM_READAHEAD_BUFFERS.
	Rozwi±zanie zadania znajduje siê w pliku <i>aio-copy-readahead.c</i>.</li></ol>

<hr>
<i>Autor: Krzysztof Lichota <a href="mailto:lichota@mimuw.edu.pl">lichota@mimuw.edu.pl</a>
   <br>Ostatnio sprawdzone w pa¼dzierniku 2005.<br>
   Uwagi i komentarze ( w roku akademickim 2005/06 ) proszê kierowaæ 
   do <a href="mailto:r.bartosiak@mimuw.edu.pl">r.bartosiak@mimuw.edu.pl</a>.<br>Weryfikacja dla j±dra 2.6.x, usuniêcie sprintf() z przyk³ad&oacute;w: Krzysztof Lichota, 9.01.2007  
</i>

</body></html>