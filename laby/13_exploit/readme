Laboratoratorium 13
===================
Bezpieczeñstwo
--------------

Literatura
----------
  + http://www.sco.com/developers/devspecs/abi386-4.pdf , s. 35
  + inted(8), objdump(1), nc(1) 

Pliki z których bêdziemy korzystaæ
----------------------------------
   server.c - przyk³adowy serwer którego lukê w bezpieczeñstwie wykorzystamy
   exploit.c - gotowy program wykorzystuj±cy lukê serwera
   payload.s - kod który zostanie wykonany na komputerze ofiary
   demo.c - po¶redni etap tworzenia exploit.c
   dump_vdso.c - pomocniczy program s³u¿±cy do obejrzenia VDSO
   exec.c - program wykonuj±cy execve

Makefile
--------
   make skompiluje server payload i demo.
   make show-exec poka¿e zdeasemblowany kod programu exec
   make show-payload poka¿e gotowy do wklejenia kod maszynowy payload'a
   make show-vdso na Linuksie poka¿e deasemblacjê vdso

Cel
---
   Napisaæ program który pozwoli na przejêcie kontroli nad komputerem na którym
   chodzi serwer z pliku server.c.

Scenariusz zajêæ

1. Stos programu
   -------------
   Ka¿dy proces ma, dostarczany przez system operacyjny, stos. Nie jest on
   niczym innym jak zamapowanym, ci±g³ym fragmentem przestrzeni adresowej
   procesu oraz ustawionym rejestrem stosu (na potrzeby scenariusza - SP).
   Na stosie odk³adane s± zmienne lokalne, adresy powrotu wykonywanych w danej
   chwili funkcji oraz czê¶ciowe wyniki obliczeñ.

   Implementacja operacji jest trywialna:
   - po³o¿enie danych na stos to zapis do pamiêci wskazywanej przez rejestr SP i
   modyfikacja tego rejestru o rozmiar zapisanych danych
   - zdjêcie danych ze stosu to odczyt spod SP i modyfikacja SP o rozmiar
   zdejmowanych danych

   System operacyjny mapuje programom z góry ustalon± ilo¶æ pamiêci na stos
   (rzêdu 2 stron) a kolejne strony pamiêci alokuje dopiero gdy zachodzi taka
   potrzeba.

2. i386
   ----
   Na potrzeby tego scenariusza skupimy siê na architekturze i386:
   - SP wskazuje na bajt który jest na czubku stosu
   - stos ro¶nie w dó³, czyli po³o¿enie danych na stos oznacza zmniejszenie SP
   - na Linuksie i BSD wo³aj±cy funkcjê powinien (w klasycznym przypadku, wiêcej w
   [1]):
      - zachowaæ zawarto¶æ rejestrów innych ni¿ BP, SI, DI, BX (je¿eli bêdzie
        chcia³ ich potem u¿yæ)
      - po³o¿yæ na stos argumenty w odwrotnej kolejno¶ci ni¿ w deklaracji funkcji
      - skoczyæ do tre¶ci wo³anej funkcji k³ad±c na stos aktualne miejsce w
        kodzie programu (adres powrotu)
      - po powrocie wo³anej funkcji - zdj±æ ze stosu argumenty (wynik jest w AX)
   - wo³any powinien
      - zachowaæ rejestry BP, SI, DI, BX, je¿eli zamierza je zmieniæ
      - opcjonalnie ustawiæ rejestr BP na zawarto¶æ SP (potrzebne do uzyskania
        stack-trace'ów, upraszcza kod w asemblerze, ale nie jest obowi±zkowe, w
        gcc mo¿na wy³±czyæ generowanie takiego kodu za pomoc± flagi
        -fno-frame-pointer)
      - zarezerwowaæ miejsce na stosie na zmienne lokalne (przesuwaj±c SP)
      - wykonaæ swoj± tre¶æ
      - odtworzyæ rejestry
      - do AX wpisaæ wynik
      - skoczyæ pod adres z czubka stosu - adres powrotu, ten po³o¿ony przez
        wo³aj±cego
   
3. Wady i zalety stosu
   -------------------
   Jak widaæ z tego scenariusza alokacja zmiennych lokalnych jest bardzo szybka,
   poniewa¿ sprowadza siê do modyfikacji jednego rejestru i o ile zmienne
   lokalne s± wielokrotno¶ciami rozmiaru s³owa procesora, to nie istnieje
   problem fragmentacji. Te dwie cechy daj± alokacji na stosie du¿± przewagê nad
   alokacj± na stercie - malloc musi mieæ z³o¿on± logikê zarz±dzania pamiêci± i
   do tego trudno unikn±æ fragmentacji. Niemniej, stos nie nadaje siê do
   trzymania zmiennych, których cykl ¿ycia przekracza jedno wywo³anie funkcji.

   Inn± cech± stosu jest ³atwo¶æ przewidzenia u³o¿enia danych programu na nim i
   w przypadku b³êdnie napisanego programu wykorzystania tej wiedzy do przejêcia
   kontroli nad programem.

4. Buffer overflow
   ---------------
   Takim mianem okre¶la siê sytuacjê, kiedy z jakich¶ powodów program "zapomina"
   o faktycznym rozmiarze jakiego¶ bufora i przekracza jego granice dostaj±c siê
   do pamiêci do niego nienale¿±cej. Przyk³ad:

   char c[5];
   strcpy(c, "12345");

   strcpy() kopiuje napis do bufora przekazanego jako pierwszy argument razem z
   koñcz±cym zerem, zatem w tym przypadku 6 znaków do 5-elementowego bufora.

   Specyfikacja jêzyka na ogó³ nic o tym nie mówi, ale kompilatory zachowuj± siê
   przewidywalnie i mo¿na ³atwo odgadn±æ jak zmienne le¿± wzglêdem siebie na
   stosie (na ogó³ po kolei). Taka sytuacja powoduje, ¿e szczególny przypadek
   przepe³nienia bufora - stack buffer overflow, mo¿na ³atwo wykorzystaæ,
   poniewa¿ przekraczaj±c granicê bufora wystarczaj±co, mo¿na nadpisaæ adres
   powrotu z funkcji. Je¿eli zrobi siê to umiejêtnie, to mo¿na przej±æ kontrolê
   nad programem, poniewa¿ mnemonik ret w kodzie atakowanego programu doprowadzi
   do skoku w miejsce wpisane w adres powrotu.

5. inetd
   -----
   inetd jest standardowym uniksowym demonem, tzw. superserwerem. W pliku
   konfiguracyjnym inetd.conf przypisuje siê programy do ró¿nych us³ug
   sieciowych, np. proftpd do us³ugi ftp. inetd nas³uchuje na odpowiednich
   portach i w momencie nawi±zania po³±czenia uruchamia program w³a¶ciwy us³udze
   z deskryptorami 0 i 1 ustawionymi tak, ¿e program wysy³a dane przez sieæ
   pisz±c na standardowe wyj¶cie a odczytuje dane czytaj±c ze standardowego
   wej¶cia. Niegdy¶ to podej¶cie by³o zdecydowanie bardziej popularne ni¿ dzi¶,
   choæ wci±¿ demon ten jest powszechny.

5. Piszemy exploita
   ----------------
   exploit - potoczna nazwa na program który wykorzysta wadê innego programu.

   Je¿eli jeste¶my w stanie wytropiæ sytuacjê, która pozwala na dowolne
   przekroczenie rozmiaru bufora, to mo¿emy pozwoliæ sobie na takie nadpisanie
   adresu powrotu, ¿eby program zrobi³ to, czego chce atakuj±cy.

   Dla uproszczenia przyjmijmy, ¿e mamy do czynienia z takim kodem (server.c):
   
   void test()
   {
      char buf[4];
      gets(buf);
   }

   int main()
   {
      while (1) {
         test();
         printf("hello\n");
      }
      return 0;
   }

   Przyjmujemy, ¿e kod ten jest uruchomiony poprzez inetd. Naszym celem bêdzie
   uzyskanie wszystkiego tego, co mo¿e u¿ytkownik, w którego imieniu dzia³a ten
   program.


   Szkic tego co napiszemy:
   - prze¶lemy kod do wykonania (tzw. payload)
   - oprócz payload-a prze¶lemy takie dane, ¿eby zamiast powrotu z funkcji test()
     wykonany zosta³ payload
   
   Problemy:
   - sprawdziæ jak du¿o ¶mieci trzeba wstawiæ przed sfingowany adres powrotu w
     trefnym komunikacie ¿eby trafiæ w odpowiednie miejsce na stosie
   - dowiedzieæ siê czym nadpisaæ adres powrotu, ¿eby skoczyæ do payload'a
   - napisaæ payload który zrobi co¶ sensownego

   Dowiedzieæ siê gdzie jest adres powrotu, maj±c kod ¼ród³owy, jest ³atwo -
   wystarczy policzyæ maj±c na uwadze jak wygl±da wo³anie funkcji na i386. Gdy
   kodu nie ma, mo¿na to zrobiæ robi±c zrzut pamiêci (stosu) i od koñca stosu
   (jest znany, bo znany jest rejestr SP) poszukaæ wyrównanych do 4 bajtów
   liczb, które wskazuj± na obszar pamiêci w którym odwzorowany jest kod
   programu.

   Wiêkszy problem stanowi dowiedzenie siê gdzie skoczyæ, poniewa¿:
   - adres stosu przyznawany jest przez system operacyjny
   - na pierwszy rzut oka nie bardzo wiadomo, co jest na tym stosie poni¿ej
     funkcji main
   - nawet je¿eli czytaj±c kod libc i j±dra dowiemy siê co i ile tego jest na
     stosie poni¿ej funkcji main, to oka¿e siê, ¿e nie jest to sta³a liczba, bo
     zale¿y np. od:
     - rozmiaru argumentów przekazanych do programu
     - ¶rodowiska

   Szczê¶liwie, du¿a czê¶æ systemów ma adres pocz±tku stosu zawsze taki sam -
   bliski koñca przestrzeni wirtualnej procesu, wiêc wahania po³o¿enia tego
   bufora nie mog± byæ bardzo du¿e - zale¿± g³ównie od ¶rodowiska i argumentów
   programu. St±d te¿ wahania adresu bufora da siê sensownie oszacowaæ -
   wystarczy uruchomiæ program z pustym ¶rodowiskiem w katalogu /, bez
   argumentów i sprawdziæ adres dowolnej zmiennej lokalnej. Prawie na pewno nie
   zdarzy siê sytuacja, ¿e stos pod funkcj± main bêdzie wiêkszy. Mamy wiêc
   jedno ograniczenie, a jako drugie nale¿y przyj±æ sensowne ograniczenie na
   ¶rodowisko i argumenty.

   Je¿eli stworzymy zatem tak± sytuacjê na stosie:

   WYSOKIE ADRESY

   Przed atakiem                              Po ataku
   +-----------------------------------------++-----------------------------------------+
   |                                         || payload                                 |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |                                         || NOP                                     |
   +-----------------------------------------++-----------------------------------------+
   |   adres powrotu                         ||   trefny adres powrotu                  |
   +-----------------------------------------++-----------------------------------------+
   |   opcjonalnie zachowane rejestry        ||   ¶mieci                                |
   +-----------------------------------------++-----------------------------------------+
   |   bufor                                 ||   ¶mieci                                |
   +-----------------------------------------++-----------------------------------------+

   NISKIE ADRESY

      * NOP odpowiada jakiej¶ operacji która nic nie robi

   to wystarczy, ¿e trefny adres powrotu wska¿e dowoln± instrukcjê NOP. Je¿eli
   bêdzie ich wystarczaj±co du¿o, to mo¿emy w ten sposób zniwelowaæ wahania
   adresu bufora. Ta technika, czyli wstawianie w bufor du¿ej liczby NOP-ów
   nazywa siê nop-slide, poniewa¿ mówi±c obrazowo, ze¶lizgujemy siê po NOP-ach do
   payload'a.

6. Technikalia
   -----------
   Wszystkie technikalia zosta³y pokazane na przyk³adzie systemu NetBSD, ¿eby
   zadaniem mog³o byæ zrealizowanie tego pod Linuksem. U¿ywane narzêdzia s± albo
   takie same jak pod Linuksem albo prawie takie same, wiêc z dok³adno¶ci± do
   szczegó³ów nie powinno to stanowiæ przeszkody.

   Narzêdzia:
   - objdump: program deasembluj±cy skompilowane programy - przyda siê do
     analizy, zw³aszcza z flag± -d
   - ulimit: program zarz±daj±cy limitami u¿ytkownika - tylko po to aby
     poprosiæ j±dro o robienie zrzutów pamiêci (core dump) w przypadku kiedy
     program siê wysypie - przydatne w debugowaniu (flaga -c)
   - gdb: debugowanie z mo¿liwo¶ci± wczytania zrzutu pamiêci
   - gcc: do kompilacji programów w tym payloada
   - /proc/self/maps: ten plik w linuksie pokazuje mapowania pamiêci procesu, co
     pozwala przekonaæ siê gdzie zaczyna siê stos
   - netcat (nc): program który pos³u¿y nam do przes³ania exploita przez sieæ
   
   
7. Implementacja krok po kroku
   ---------------------------
   Najprostszym i najbardziej efektownym payloadem bêdzie uruchomienie pow³oki,
   czyli wykonanie execve. Poniewa¿ uruchamiany program dziedziczy deskryptory,
   a program uruchomiony w inetd u¿ywa deskryptorów 0, 1 i 2 do komunikacji
   przez sieæ, to na skutek zawo³ania execve osi±gniemy efekt podobny do zdalnej
   pow³oki.

   Jako ¿e nie jest jasne gdzie znajduje siê PLT (bo zale¿y to od kompilatora i
   bardzo drobnych zmian w kodzie) a tym bardziej gdzie zamapowany
   jest kod biblioteki libc, lepiej wywo³ywaæ syscalle rêcznie - z pominiêciem
   opakowañ dostarczanych przez bibliotekê standardow±.

   Sposób mo¿na znale¼æ w dokumentacji systemu operacyjnego albo czytaj±c jego
   kod, najszybciej jednak chyba zrobiæ to kompiluj±c statycznie program
   wywo³uj±cy interesuj±cego nas syscalla. Za³±czony plik exec.c po
   skompilowaniu do exec nale¿y obejrzeæ za pomoc± objdump -d. W przypadku
   NetBSD widaæ, ¿e wywo³anie syscalla wymaga po³o¿enia na stos argumentów,
   adresu powrotu, wpisania do AX numeru 0x3b po czym zawo³aniu przerwania 0x80.
   
   W Linuksie wywo³anie syscalla jest bardziej skomplikowane, poniewa¿ ze
   wzglêdu na zarówno potrzebê binarnej kompatybilno¶ci ze starymi wersjami
   j±dra jak i chêæ wykorzystania nowszych sposobów wykonywania syscalli,
   zastosowano tam jeszcze jedn± warstwê po¶redni± - VDSO (virtual dynamically
   shared object) czyli co¶ w stylu biblioteki dzielonej, która nie ma swojego
   odzwierciedlenia na dysku. Zawiera ona kod (specyficzny dla konkretnej wersji
   j±dra) za pomoc± którego wywo³ywane s± syscalle. Biblioteka ta jest
   w³adowywana w przestrzeñ adresow± ka¿dego procesu (widaæ to w pliku
   /proc/self/maps). ¯eby wywo³aæ syscalla nale¿y zatem albo odwo³aæ siê do tej
   biblioteki albo zobaczyæ jaki ma ona kod. W nowszych j±drach biblioteka ta
   jest ³adowana pod przypadkowy adres, wiêc ³atwiej sprawdziæ kod. Najpro¶ciej
   zrobiæ to wykonuj±c objdump -d na tym¿e kodzie. Aby siê do niego dostaæ
   wystarczy napisaæ program, który zajrzy do /proc/self/maps, przeczyta gdzie
   jest VDSO i zrzuci ten fragment na dysk. Mo¿na pos³u¿yæ siê za³±czonym
   programikiem dump_vdso.c. (make show-vdso)

   Wiedz±c ju¿ jak wykonaæ syscall'a nale¿y napisaæ programik w asemblerze,
   który wykona execve na /bin/sh.

   Przyk³ad (dla NetBSD) jest w pliku payload.s.

   Kod wykonywalny tego programu bêdzie naszym payloadem. Za pomoc± make
   show-payload mo¿na zobaczyæ ten kod w formie dogodnej do zapisania w C.

   Plik demo.c pokazuje jak mo¿na bezpo¶rednio przekazaæ sterowanie do tego kodu
   (funkcja brute_force) oraz jak nadpisaæ adres powrotu adresem payload'a.
   U¿yty tam adres jest wy³±cznie skutkiem policzenia tego co jest na stosie
   zgodnie z konwencj± wo³ania podan± na pocz±tku.

   Ostatni± rzecz± jest dostarczenie payload'a do programu z zewn±trz razem z
   trefnym adresem powrotu i NOP-slidem. Po³o¿enie adresu w buforze wynika
   bezpo¶rednio z przyk³adu demo.c. Sam adres natomiast zosta³ sprawdzony
   eksperymentalnie poprzez sprawdzenie adresu zmiennej lokalnej w funkcji
   main().

   Mo¿na obejrzeæ to w pliku exploit.c. Program ten, po wys³aniu trefnych
   danych, wkonuje exec na program cat aby mo¿na by³o zademonstrowaæ jego
   dzia³anie pisz±c:
   ./exploit | ./server

8. ATAK PRZEZ SIEÆ
   ---------------
   Aby osi±gn±æ ten sam efekt przez sieæ (inetd) nale¿y trochê poeksperymentowaæ
   z rozmiarem bufora (wielko¶ci± NOP-slide'a) i adresem pod który skaczemy.
   Nastêpnie wystarczy u¿yæ netcata (polecenie nc) do interakcji ze zdalnie
   uruchomionym serwerem, czyli pó¼niej pow³ok±. W tym celu nale¿y odpaliæ:
   ./exploit | nc adres_serwera port

   Je¿eli wszystko dobrze pójdzie to efektem bêdzie wykorzystanie luki
   20-linijkowego programu do przejêcia kontroli nad zdalnym komputerem.


9. MORA£
   -----
   Na powy¿szym przyk³adzie widaæ jak bardzo niebezpiecznym jest niechlujne
   programowanie. Pomimo tego, ¿e jest to przyk³ad na potrzeby przedmiotu, to
   mechanizm jest powszechny, stosowany i wszechobecny. Raporty bezpieczeñstwa z
   portali internetowych typu Secunia to potwierdzaj±.

   Czy mo¿na jako¶ siê przed tym broniæ? Jest wiele metod, niestety jedynie
   utrudniaj± one pracê hakerom a nie uniemo¿liwiaj±:
   - randomizacja stosu (pocz±tek stosu jest w ka¿dym procesie gdzie indziej)
   - NX bit (nowsze procesory pozwlaj± na oznaczenie fragmentu przestrzeni
     wirtualnej (stosu) jako Non-eXecutable, co spowoduje b³±d przy próbie
     uruchomienia payload'a
   - gcc ma opcjê -fstack-protector, która powoduje, ¿e gcc przy rozpoczynaniu
     wykonywania ka¿dej funkcji umieszcza na stosie "stra¿nika" czyli z góry
     okre¶lony numerek, który jest sprawdzany przed wyj¶ciem z funkcji czy nie
     zosta³ zmieniony
   - powa¿ne firewall'e wykrywaj± NOP-slide'y w pakietach i odrzucaj± je

10. ZADANIE
    -------
   Napisaæ exploita pod Linuksa i386, który w sposób opisany powy¿ej wykorzysta
   lukê z programu z pliku server.c.

   Pominiêcie warstwy sieciowej i postawienie takiego problemu te¿ nie jest
   nie¿yciowe bo jest przecie¿ ca³a masa programów, do których ka¿dy ma dostêp,
   natomiast s± one w³asno¶ci± u¿ytkownika root i maj± ustawiony bit SUID, który
   powoduje, ¿e zawsze s± wykonywane na prawach w³a¶ciciela. Przyk³adami mog±
   byæ su albo cron.

Autor: Marek Dopiera <dopiera (at) mimuw (dot) edu (dot) pl>
