<?xml version="1.0" encoding="iso8859-2"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="content-type" content= "text/html; charset=iso8859-2"/>
	<title>Zadanie 3</title>
</head>
<body>
<h1>Zadanie mysched</h1>
<p>
Zadanie polega na zaimplementowaniu biblioteki pseudo-w±tków w przestrzeni
u¿ytkownika.  Do dyspozycji s± tylko mechanizmy POSIX-owe, oczywi¶cie z
wy³±czeniem pthreads.  Dodatkowo, nale¿y zaimplementowaæ odpowiedniki funkcji
pread i pwrite, które nie blokuj± ca³ego procesu a jedynie wo³aj±ce je
pseudo-w±tki. W±tki powinny byæ wyw³aszczane.
</p>

<p>
Program mo¿e znajdowaæ siê w jednym z dwóch stanów - wykonywania pseudo-w±tków
(dostarczanych przez tê bibliotekê) lub w stanie jednow±tkowym. Biblioteka
powinna dostarczaæ funckjonalno¶ci poprzez API zdefiniowane w pliku
<a href="sched.h">sched.h</a>.<br/>
Opis definicji z tego pliku:
</p>
<ul>
	<li><pre>MYSCHED_STACK_SIZE</pre> oznacza rozmiar stosu dla jednego w±tku w
	bajtach.</li>
	<li><pre>mysched_thread_t</pre> oznacza typ po którym rozró¿niane s±
	w±tki.</li>

	<li><pre>mysched_init()</pre> funkcja inicjalizuj±ca bibliotekê - u¿ytkownik
	biblioteki ma obowi±zek zawo³aæ tê funkcjê przed u¿yciem pozosta³ych
	funkcji. W przeciwnym wypadku dowolne zachowanie jest dopuszczalne.</li>

	<li><pre>mysched_thread_t mysched_create_thread(void (*starter)(), const char *name)</pre>
	oznacza stworzenie w±tku o nazwie name który rozpocznie wykonywanie funkcji
	przekazanej jako parametr starter. Nazwy nie musz± byæ unikalne. Zwrócony ma
	zostaæ unikalny identyfikator w±tku. Przekazywany napis musi istnieæ tylko
	do koñca wywo³ania tej funkcji - nie ma potrzeby alokowania go na stercie.
	Ta funkcja nie powinna byæ wo³ana z pseudo w±tków. Jest to jedynie
	przygotowanie odpowiednich struktur.</li>

	<li><pre>mysched_thread_t mysched_self()</pre> funkcja powinna zwróciæ
	identyfikator w±tku z którego jest zawo³ana. Dopuszczalne jest dowolne
	zachowanie, gdy zostanie zawo³ana spoza w±tku (np. przed uruchomieniem
	mysched_go()).</li>

	<li><pre>char * mysched_get_name(mysched_thread_t thread)</pre> ma
	zwróciæ nazwê odpowiedniego w±tku podan± podczas jego tworzenia. U¿ytkownik
	biblioteki staje siê w³a¶cicielem pamiêci wskazywanej przez zwrócony
	wska¼nik - na nim spoczywa odpowiedzialno¶æ jej zwolnienia.</li>

	<li>
<pre>
ssize_t mysched_pwrite(int d, const void *buf, size_t nbytes, off_t offset)
ssize_t mysched_pread(int d, void *buf, size_t nbytes, off_t offset);
</pre>
	maj± symulowaæ wywo³ania systemowe pwrite i pread. Poni¿ej opisana jest
	sugerowana implementacja. Nie nale¿y u¿ywaæ tutaj zwyk³ych pread/pwrite,
	poniewa¿ one blokuj± ca³y proces a nie tylko wo³aj±cy pseudo-w±tek.</li>

	<li><pre>void mysched_go()</pre> ta funkcja powinna zostaæ zawo³ana po
	utworzeniu w±tku/w±tków. Nie powinna byæ wo³ana z pseudo-w±tków. Jej
	zawo³anie powinno rozpocz±æ wykonywanie w±tków. Funkcja powinna wróciæ gdy
	wszystkie w±tki zakoñcz± siê. Je¿eli po jej zawo³aniu zostan± stworzone nowe
	w±tki a ona zostana zawo³ana ponownie, to równie¿ powinno to zadzia³aæ
	prawid³owo.</li>
</ul>
<p>Inne uwagi dotycz±ce funkcjonalno¶ci</p>
<ul>
	<li>W±tek koñczy siê, gdy zostanie opuszczona funkcja przekazana do 
	mysched_create_thread().</li>
	<li>Powinna dzia³aæ domy¶lna obs³uga sygna³ów SIGQUIT i SIGINT</li>
	<li>Zak³adamy, ¿e u¿ytkownik nie bêdzie u¿ywa³ sygna³ów SIGUSR1, SIGUSR2,
	SIGPROF i nie bêdzie korzysta³ z funkcjonalno¶ci pthreads.</li>
	<li>Zachowanie przy forku i execu mo¿e byæ dowolne.</li>
</ul>
<p>Uwagi dotycz±ce implementacji</p>
<ul>
	<li>Nie nale¿y u¿ywaæ pthreads</li>
	<li>Nale¿y u¿ywaæ tylko mechanizmów POSIX-owych. setcontext i getcontext
	uznajemy za nienale¿±ce do POSIX, poniewa¿ zosta³y usuniête z najnowszej
	jego wersji</li>
	<li>Zadanie powinno dzia³aæ zarówno na 32 jak i 64 bitach i w miarê
	mo¿liwo¶ci nie zak³adaæ nic o architekturze i systemie operacyjnym.</li>
	<li>Nale¿y dostarczyæ pliki z kodem w C oraz Makefile do skompilowania ich
	do statycznej biblioteki o nazwie sched.a implementuj±cej plik nag³ówkowy z
	zadania (nale¿y u¿yæ narzêdzia ar(1) do spakowania plików *.o - tutoriale w
	google).</li>
	<li>Strategia prze³±czania w±tków mo¿e byæ dowolna o ile bêdzie fair
	wobec wszystkich w±tków - np. round-robin.</li>
	<li>Ustalamy, ¿e sygna³em do tworzenia nowego w±tku bêdzie SIGUSR1, sygna³em
	o zakoñczeniu AIO - SIGUSR2, a sygna³em od timera SIGPROF. (opisane
	poni¿ej)</li>
</ul>
<h2>Wskazówki</h2>
<h3>setjmp i longjmp</h3>
<p>
Prost± i przeno¶n± metod± na prze³±czanie kontekstu s± funkcje setjmp(3) i
longjmp(3). Dok³adny opis znajduje siê w manach, tutaj jest skrócony.
</p>
<p>
Funkcje te s³u¿a do zachowywania i odtwarzania stanu programu. Przez stan
rozumiane s± rejestry (w tym czubek stosu) i maska sygna³ów. Stan zachowywany
jest w zmiennej typu jmp_buf, która jest przekazywana do obu tych funkcji.
Sygnatury s± nastêpuj±ce:
</p>
<pre>
int setjmp(jmp_buf env);
void longjmp(jmp_buf env, int val);
</pre>
<p>
Zawo³anie setjmp spowoduje zapisanie stanu programu do env. Zwrócona zostanie
warto¶æ 0. Gdy pó¼niej w programie zostanie zawo³ane longjmp z tym samym env i
warto¶ci± val, to stan programu zostanie przywrócony do momentu w którym zosta³o
zawo³ane setjmp - czyli z perspektywy programisty bêdzie to wygl±da³o tak jakby
zakoñczy³o siê wykonanie odpowiedniej funkcji setjmp. Aby odró¿niæ sytuacjê
zawo³ania setjmp po raz pierwszy i powrotu do niego na skutek longjmp, setjmp
zwróci val przekazane w longjmp je¿eli bêdzie to powrót i 0 gdy bêdzie to
wywo³anie funkcji setjmp.
</p>
<p>
Niestety ten mechanizm jest do¶æ prymitywny i sprowadza siê do zapamiêtania
rejestrów i maski sygna³ów, czyli w szczególno¶ci nie kopiuje stosu. To jest
przyczyna, dla której funkcja, która wywo³a³a setjmp nie mo¿e zostaæ opuszczona
je¿eli w przysz³o¶ci ma nast±piæ wywo³anie odpowiedniego longjmp. Gdyby tak siê
sta³o, to na szczycie stosu by³yby ¶mieci. Widaæ, ¿e to nie wystarcza, aby
dostarczyæ funkcjonalno¶ci w±tków.
</p>
<h3>Nowy stos</h3>
<p>
Aby mieæ funkcjonalno¶æ w±tków, nale¿y ka¿demu przydzieliæ osobny stos. Niestety
POSIX nie daje mo¿liwo¶ci definiowania nowych stosów jawnie, wiêc trzeba
zastosowaæ hakersk± sztuczkê: u¿yæ alternatywnego stosu do obs³ugi sygna³ów do
definiowania nowych stosów dla w±tków.
Scenariusz postêpowania jest nastêpuj±cy:
</p>
<ul>
	<li>Zaalokowaæ na stercie kawa³ek miejsca, który bêdzie stosem w±tku</li>
	<li>Za pomoc± sigaltstack(2) za¿yczyæ sobie, aby to miejse by³o
	alternatywnym stosem dla wywo³ania funkcji obs³ugi sygna³ów</li>
	<li>Za pomoc± sigaction(2) zarejestrowaæ siê na ustalony sygna³ podaj±c
	flagê SA_ONSTACK</li>
	<li>Za pomoc± raise(3) wys³aæ do siebie ten¿e ustalony sygna³</li>
	<li>W procedurze obs³ugi sygna³u trzbea zawo³aæ setjmp i powróciæ z funkcji
	obs³ugi sygna³u</li>
</ul>
<p>
W ten sposób zostanie zapisany stan wskazuj±cy na inny stos, wiêc spokojnie
mo¿na u¿yæ longjmp do tego stanu w dowolnym momencie. Nale¿y tylko zastanowiæ
siê, co i kiedy zrobiæ z mask± sygna³ów. To jest sposób na utworzenie nowego
w±tku.
</p>
<h3>Wyw³aszczanie</h3>
<p>
Do przerywania pracy procesu ¶wietnie nadaj± siê sygna³y, dlatego mo¿na
wykorzystaæ je do wyw³aszczania w±tków i prze³±czania kontekstu na inny w±tek i
w ten sposób otrzymaæ wspó³bie¿no¶æ. Mo¿na do tego u¿yæ setitimer(2), który
rozkazuje systemowi operacyjnemu dostarczaæ sygna³ do procesu raz na ustalony
czas. Udostêpnia on trzy typy timerów, które mierz± czas na ró¿ne sposoby:
rzeczywisty, faktyczny czas spêdzony przez proces w przestrzeni u¿ytkownika oraz
czas spêdzony zarówno w przestrzeni u¿ytkownika jak i czas który j±dro spêdzi³o
na ¿±daniach procesu. Nale¿y u¿yæ tego trzeciego.
</p>
<h3>Wej¶cie / wyj¶cie</h3>
<p>
Je¿eli chcemy dostarczyæ odpowiedników funkcji pread/pwrite które bêd± blokowaæ
tylko wo³aj±cy je w±tek, to nie mo¿emy u¿yæ pwrite/pread, bo zablokowany
zostanie ca³y proces. Aby tego unikn±æ mo¿na pos³u¿yæ siê POSIX AIO, które nie
blokuje procesu i za¿yczyæ sobie powiadomienia o zakoñczeniu operacji poprzez
sygna³. Do czasu nadej¶cia takiego powiadomienia nale¿y wykonywaæ tylko w±tki
które nie czekaj± na AIO. Je¿eli takich nie ma, nale¿y u¿yæ aio_suspend(3), aby
unikn±æ aktywnego oczekiwania. Gdy nadejdzie sygna³ mówi±cy o zakoñczeniu
dzia³ania w±tku, trzeba sprawdziæ którego w±tku by³a to operacja (za pomoc±
aio_error(3)) i oznaczyæ ten w±tek jako w±tek gotowy do wykonania.
</p>
<hr/>
<p>
<small>Autor: <i>Marek Dopiera &lt; dopiera (at) mimuw (dot) edu (dot) pl &gt;</i></small>
</p>
</body>
</html>

